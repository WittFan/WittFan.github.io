<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pandas read_table]]></title>
    <url>%2F2019%2F08%2F09%2Fpandas-read-table%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/u012131430/article/details/78299582]]></content>
  </entry>
  <entry>
    <title><![CDATA[商品期货协整配对]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%95%86%E5%93%81%E6%9C%9F%E8%B4%A7%E5%8D%8F%E6%95%B4%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[https://uqer.io/v3/community/share/57b52ac0228e5b79aa759416]]></content>
  </entry>
  <entry>
    <title><![CDATA[平稳性检验]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B9%B3%E7%A8%B3%E6%80%A7%E6%A3%80%E9%AA%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python模块: deque]]></title>
    <url>%2F2019%2F08%2F09%2Fpython%E6%A8%A1%E5%9D%97-deque%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[为markdown创建一个新标记符]]></title>
    <url>%2F2019%2F08%2F04%2F%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[问题的由来当我们在编写markdown文件的时候会经常从网页上ctr+c其他人的文字，而我们标注作者和文章的来源不是特别方便，这会导致许多时候我们不去标注作者和文章的来源。引文规范对于问题追溯和文明发展相当重要，与其道德说教来让大家遵守引文规范，不如提供更方便的方式来让大家遵守，因此，本文抛砖引玉出一种新的高效的规范和工具。 复制时天生携带引文信息将下面的javascript语句放到网页的head处 1234567891011121314&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt; 示例如下 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;测试1&lt;br&gt;测试2&lt;/body&gt;&lt;/html&gt; 当我们运行网页，复制网页中内容后，将其粘贴到mardown文件，会得到下面的结果 而其（在vscode+MarkDownPreview中）渲染成html的显示效果如下图这样我们就可以在不影响显示的情况下保留其引文信息。当然，html中保留引文信息的工作需要在markdown文件转换为html文件的过程中完成，转换工具和规范这里不做讨论，先留下个坑，或者其他人来完成吧，😃。 hexo的next主题下复制时附加引文信息找到hexo项目根目录，我的根目录是/blog在 ../blog/themes/next/layout/_partials/head目录下找到custom-head.swig文件，将下面的代码添加到文末就可以了。 1234567891011121314&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt; 将hexo-next下的文末出处去掉将文件../blog/themes/next/_config.yml（blog为我的hexo根目录）中的post_copyright项下的enable的值从true改为false 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 改完后为 12345# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 之后文章末尾就不会再出现下图的情形了 如果使用了代码复制功能怎么改当使用代码复制功能的时候，我们希望复制到干净的代码，却不想得到引用信息;而在复制文章内容的时候，我们希望得到引文信息。 笔者使用的是这个链接下实现的代码复制功能，https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%89/ 我的办法是：将clipboard-use.js文件的代码进行了一下升级，加了if语句。可以理解成将custom-head.swig文件里的那个添加引用的代码整合到了clipboard-use.js文件里。 1234567891011121314151617181920212223242526272829303132333435363738394041 /*页面载入完成后，创建复制按钮*/var btnCopyEmpty = true;document.addEventListener("copy", copy);function copy(oEvent)&#123; var selection = window.getSelection(); if(btnCopyEmpty)&#123; console.log(btnCopyEmpty) var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; &#125;else&#123; var copytext = selection; &#125; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext);&#125;;!function (e, t, a) &#123; /* code */var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; btnCopyEmpty = false; return trigger.nextElementSibling; &#125; &#125;); // clipboard.on('success', function(e)&#123; // btnCopyEmpty = false; // &#125;);&#125;initCopyCode();&#125;(window, document);]]></content>
      <categories>
        <category>programming/nodejs/hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>javascript</tag>
        <tag>quote</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test password]]></title>
    <url>%2F2019%2F08%2F04%2Ftest-password%2F</url>
    <content type="text"></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数getitem系列]]></title>
    <url>%2F2016%2F08%2F12%2Fpython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0getitem%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[123456789101112131415class DictDemo: def __init__(self,key,value): self.dict = &#123;&#125; self.dict[key] = value def __getitem__(self,key): return self.dict[key] def __setitem__(self,key,value): self.dict[key] = value def __len__(self): return len(self.dict)dictDemo = DictDemo('key0','value0')print(dictDemo['key0']) #value0dictDemo['key1'] = 'value1'print(dictDemo['key1']) #value1print(len(dictDemo)) #2]]></content>
  </entry>
  <entry>
    <title><![CDATA[from eval to getattr hasattr setattr]]></title>
    <url>%2F2016%2F08%2F12%2Ffrom%20eval%20to%20getattr%20hasattr%20setattr%2F</url>
    <content type="text"><![CDATA[现实中的问题：我手中有一个列表[（’请求网页’,’网页1’）,（’解析网页’,’网页1’, (‘保存网页’, ‘网页1’),’请求网页’,’网页2’）,（’解析网页’,’网页2’, (‘保存网页’, ‘网页2’),… ]，想将列表中的事情从头到尾都干一遍。 首先，定义一个类 1234567class Spider: def request(self, page): print('请求网页:', page) def parse(self, page): print('解析网页:', page) def save(self, page): print('保存网页:', page) 然后我们想的是，如何复用Spider里的方法许多人的做法是直接使用eval做法如下 12345todo_lst = [('request', 'www.exobrain.online'), ('parse', 'www.exobrain.online'), ('save', 'www.exobrain.online'),('request', 'www.exobrain.online/categories/'), ('parse', 'www.exobrain.online/categories/'), ('save', 'www.exobrain.online/categories/'), ('方法测试1','www.exobrain.online/categories/')]spider = Spider()for item in todo_lst: string = 'spider.' + item[0]+'("'+item[1]+'")' eval(string) 出来了结果 123456789请求网页: www.exobrain.online解析网页: www.exobrain.online保存网页: www.exobrain.online请求网页: www.exobrain.online/categories/解析网页: www.exobrain.online/categories/保存网页: www.exobrain.online/categories/...AttributeError: &apos;Spider&apos; object has no attribute &apos;错误的方法测试1&apos;(报错：部分) 我们看到了报错，自然可以用try except处理。but，eval is evil, it’s not suggested. If you use eval, python is no longer elegant.So, we introduce the inbuit methods “getattr, hasattr, setattr“（参考自https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string不得不感慨国内外的差距，人家11years前解决的问题，我们到现在还有好多程序员处于问题之中，还在大量使用eval()。） 使用getattr代替eval, 将for部分注释掉重写如下 1234567891011todo_lst = [('request', 'www.exobrain.online'), ('parse', 'www.exobrain.online'), ('save', 'www.exobrain.online'),('request', 'www.exobrain.online/categories/'), ('parse', 'www.exobrain.online/categories/'), ('save', 'www.exobrain.online/categories/'), ('方法测试1','www.exobrain.online/categories/')]spider = Spider()# for item in todo_lst:# string = 'spider.' + item[0]+'("'+item[1]+'")'# eval(string)for item in todo_lst: if not hasattr(spider, item[0]): print('Spider类里不存在方法:', item[0]) continue getattr(spider, item[0])(item[1]) 我们看到了漂亮的结果，有没有发现上面的hasattr+getattr的代码比eval的代码更加优雅。I choose getattr instead of eval just because of elegance. 😃 1234567请求网页: www.exobrain.online解析网页: www.exobrain.online保存网页: www.exobrain.online请求网页: www.exobrain.online/categories/解析网页: www.exobrain.online/categories/保存网页: www.exobrain.online/categories/Spider类里不存在方法: 方法测试1 动态将函数添加到类或者对象里面 12345678910111213141516171819202122def method_added(page): print('调用method_added函数',page)# 将method_added 注册到spider对象里setattr(spider, 'method_added', method_added)# 测试method_added是否添加到spider对象里print(hasattr(spider, 'method_added'))# &gt;True 返回值为True, 添加成功getattr(spider, 'method_added')('www.exobrain.online')# &gt; 调用method_added函数 www.exobrain.onlinedef method_added2(self, page): print('调用method_added2函数',page)# 将method_added2 注册到Spider类里setattr(Spider, 'method_added2', method_added2)# 测试method_added是否添加到spider对象里print(hasattr(spider, 'method_added2'))# &gt;True 返回值为True, 添加成功getattr(spider, 'method_added2')('www.exobrain.online')# &gt; 调用method_added函数 www.exobrain.online 对于函数调用怎么办？我们可以使用locals 和 globals。locals() 和 globals() 是python的两个内置函数，通过它们可以一字典的方式访问局部和全局变量。 1234567891011121314151617def foo(): print "foo"def bar(): print "bar"func_list = ["foo","bar"]for func in func_list: locals()[func]()# &gt;foo# &gt;barfor func in func_list: globals()[func]()# &gt;foo# &gt;bar 参考：https://segmentfault.com/a/1190000010476065https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string]]></content>
      <categories>
        <category>python/内置函数/getattr系列</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>eval</tag>
        <tag>getattr</tag>
        <tag>hasattr</tag>
        <tag>setattr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[foo and bar 是个啥？]]></title>
    <url>%2F2016%2F08%2F12%2Ffoo-and-bar-%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[foo &lt;– fu &lt;– fuck up 一团糟bar &lt;– beyond all recognition![foo_and_bar.jpg]foo_and_bar.jpg]]></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.gca:polar]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-gca-polar%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021""" demo09_3d_polar.py 3d 极坐标系"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据t = np.linspace(0, 4*np.pi, 1000)r = 0.8 * t# 绘制plt.figure('3D Polar', facecolor='lightgray')plt.title('3D Polar', fontsize=18)ax3d = plt.gca(projection='polar')ax3d.set_xlabel(r'$\theta$', fontsize=14)ax3d.set_ylabel(r'$\rho$', fontsize=14)plt.tick_params(labelsize=10)plt.grid(linestyle=':')plt.plot(t, r)plt.savefig('3d_polar.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>polar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot_wireframe]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-plot-wireframe%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930""" demo07_3d_wireframe.py 3d 曲面图"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制plt.figure('3D surface', facecolor='lightgray')plt.title('3D Surface', fontsize=18)ax3d = plt.gca(projection='3d') # class axes3dax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)ax3d.plot_wireframe(x, y, z, cmap='jet', rstride=30, cstride=30)plt.tick_params(labelsize=10)# set spines invisible for error of tight_layout()for spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.savefig('3d_wireframe.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>plot_wireframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot_surface]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-plot-surface%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233""" demo07_3dsurface.py 3d 曲面图"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制plt.figure('3D surface', facecolor='lightgray')plt.title('3D Surface', fontsize=18)ax3d = plt.gca(projection='3d')ax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)ax3d.plot_surface(x, y, z, cmap='jet', rstride=30, # 行跨距 cstride=30) # 列跨距plt.tick_params(labelsize=10)# set unused spines invisible to fix error of tight_layoutfor spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>plot_surface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.3dscatter]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-3dscatter%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930""" demo06_3dscatter.py 3D图"""import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dn = 300x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)z = np.random.normal(0, 1, n)# 绘制三维散点图plt.figure('3D Scatter', facecolor='lightgray')ax3d = plt.gca(projection='3d') # 创建三维坐标系plt.title('3D Scatter', fontsize=20)ax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)plt.xticks([-3, -2, -1, 0, 1, 2, 3])plt.yticks([-3, -2, -1, 0, 1, 2, 3])plt.tick_params(labelsize=9)d = np.sqrt(x**2 + y**2 + z**2)ax3d.scatter(x, y, z, marker='o', s=70, c=d, alpha=.5, cmap='jet')# make unused spines invisible to fix error of tight_layoutfor spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.savefig('3d-scatter.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>3dscatter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交易频率]]></title>
    <url>%2F2016%2F08%2F09%2F%E4%BA%A4%E6%98%93%E9%A2%91%E7%8E%87%2F</url>
    <content type="text"><![CDATA[首先，在交易之前你必须明确每个模型位于交易频谱的哪个频段。以下图为例，股指期货500毫秒级（指行情切片，并非交易频率）的跨期套利属于次高频，这是目前中国市场的天花板；题主所谓的中低频统计套利，应该分布在准低频、次低频以及次长仓的部分。频谱不同位置的模型相关性很低，在组合管理时甚至有对冲之效。所以不存在因为高频套利导致中低频机会减少的状况。link 其次，我们一般从三个维度去考量一个交易模型：盈利，风险，容量。 盈利比较常见的指标是 Annualized Return，风险比较常见的指标是 Maximum Drawdown，也有复合型的比如 Sharpe Ratio，Calmar Ratio，等等。容量则是指该模型所能管理的最大资金规模。在传统的“弱有效市场”假设下，这三个维度的要求无法在单一策略中全部满足。所以我们通常会牺牲其一： 你想要盈利高、容量大，则必须承受不小风险，比如动量类，被认为助涨助跌的趋势策略等；你想要风险低、容量大，则收益率很难上得去，比如机构最流行的期现套利、阿尔法套利等；你想要盈利高、风险低，则不可能容纳大资金，比如题主所说的高频跨期套利。举个例子，股指期货早期的市场微观结构非常粗糙，某个高频模型可以管理2000万人民币左右，平均每天的毛利率约为1%，纯利润大概在2~3‰（由于交易次数多，几乎无单日亏损）；也就是说，每天可以稳定地套到20万左右的毛利，其中约15万作为手续费上缴交易所，自己留下5万养矿工，养码农，必要时还要养监管层的朋友。但随着争夺套利机会的交易者日渐增多，该模型不仅寿命缩短（平均一个月就需要大修），而且管理规模也锐减到数百万的量级，基本相当于残废的水平。如果我想继续用它来管理2000万的账户，则必须付出收益率大幅下降的代价。这就是之前所说的此消彼长。 按照上述归类标准，中低频统计套利属于盈利高、风险大、容量大的策略类型，与高频套利不在同一个次元。假设单笔胜率同为70%，高频每天交易上千笔，根据大数定律，单日胜率几乎收敛到1；而中低频几天做一笔，遇到价差的结构性变化时难免资金回撤，但赚到一笔的利润胜过高频千笔。 正是对这些利润的追求，保证了股指期货各合约之间的价差不会出现大幅的非理性偏离：高频消灭微观上的偏离，而中低频消灭宏观上的偏离。他们各司其职，互相尊重，互不干涉内政。不过话说回来，现在最流行的政治正确，就是高频搞乱了市场，制造了恐慌，必须杀无赦，斩立决。所以题主你如果非要说高频套利太多，导致中低频的机会减少，似乎也并没有什么不对。以上 作者：王不二链接：https://www.zhihu.com/question/33792270/answer/58689716来源：知乎]]></content>
      <categories>
        <category>finance/hedging/concept</category>
      </categories>
      <tags>
        <tag>传统套利</tag>
        <tag>统计套利</tag>
        <tag>趋势套利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传统套利、统计套利、趋势套利]]></title>
    <url>%2F2016%2F08%2F09%2F%E4%BC%A0%E7%BB%9F%E5%A5%97%E5%88%A9%E3%80%81%E7%BB%9F%E8%AE%A1%E5%A5%97%E5%88%A9%E3%80%81%E8%B6%8B%E5%8A%BF%E5%A5%97%E5%88%A9%2F</url>
    <content type="text"><![CDATA[传统套利(无风险套利) 传统套利包括价差交易和对冲交易两种类型。统计套利 统计套利是只针对有稳定性的价格关系进行的。 那些没有稳定性的价格关系的套利风险是很大的。价格关系是否稳定直接决定着统计套利能否成立，因此在对价格关系的历史数据进行统计分析的时候，首先要检验价格关系在历史数据中是否稳定。一组价格关系如果是稳定的，那么必定是存在着某一种均衡关系维持机制，一旦价格关系偏离均衡水平，维持机制就会起作用，将价格关系或快或慢地拉回到均衡水平。趋势套利 统计套利和趋势追踪正好是相反的交易理念，趋势追踪讲究只追踪不预测，而统计套利则是从历史数据分析出数据规律，认为该规律会继续延续，对未来进行预测，并通过计算出数据分布的概率来确定交易时机有协整关系的两个标的，价差价比不但有回归特性也可能有趋势特性，也自然的因为品种特性的不同，有的品种趋势特性偏强，而有的品种回归特性偏强 http://blog.sina.com.cn/s/blog_4e08635b0102xv18.html]]></content>
      <categories>
        <category>finance/hedging/concept</category>
      </categories>
      <tags>
        <tag>传统套利</tag>
        <tag>统计套利</tag>
        <tag>趋势套利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.pie]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-pie%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122""" demo03_pie.py 饼状图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据labels = ['Python', 'JavaScript', 'C++', 'Java', 'PHP']values = [26, 17, 21, 29, 11]spaces = [0.05, 0.01, 0.01, 0.01, 0.01]colors = ['dodgerblue', 'orangered', 'limegreen', 'violet', 'gold']plt.figure('pie', facecolor='lightgray')# title 不显示中文plt.title(r'Pie Figure')# 等轴比例plt.axis('equal')plt.pie(values, spaces, labels, colors, '%.2f%%', shadow=True, startangle=0, radius=1)plt.savefig('Pie.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>pie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.contour]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-contour%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526""" demo04_contour.py 绘制等高线图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制等高线plt.figure('Contour', facecolor='lightgray')plt.title('Contour', fontsize=18)plt.grid(linestyle=':')cntr = plt.contour(x, y, z, 8, colors='black', linewidths=.5)# 绘制等高线的高度标签文本# inline_spacing 空白间距plt.clabel(cntr, inline_spacing=1, fmt='%.2f', fontsize=10)# 填充等高线plt.contourf(x, y, z, 8, cmap='jet')plt.savefig('Contour.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>contour</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.imshow]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-imshow%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021""" demo04_imshow.py 绘制热成像图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制等高线plt.figure('Imshow', facecolor='lightgray')plt.title('Imshow', fontsize=18)plt.grid(linestyle=':')plt.imshow(z, cmap='jet', origin='lower')plt.colorbar()plt.savefig('Imshow.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>imshow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-plot%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.scatter]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-scatter%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.bar]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-bar%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltapples = np.array([91, 86, 23, 89, 45, 62, 39, 84, 88, 99, 21, 33])oranges = np.array([94, 59, 23, 21, 36, 91, 26, 23, 12, 199, 33, 44])plt.figure('Bar Chart', facecolor='lightgray')plt.title('Bar Chart', fontsize=18)plt.xlabel('Month', fontsize=16)plt.ylabel('Volume', fontsize=16)plt.tick_params(labelsize=10)plt.grid(linestyle=':')x = np.arange(1, 13)plt.bar(x-0.2, apples, .4,color='dodgerblue', label='Apple')plt.bar(x+0.2, oranges, .4,color='orangered', label='Orange')# 修改x的刻度文本plt.xticks(x, ['Jan', 'Feb', 'Mar', 'Apr', 'Mar', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])plt.legend()plt.savefig('Bar.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>bar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.fill_between]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-fill-between%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324""" demo_01_fill.py plot里的填充"""import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 8*np.pi, 1000)sinx = np.sin(x)cosx = np.cos(x/2)/2plt.figure('Fill', facecolor='lightgray')plt.title('Fill', fontsize=18)plt.grid(linestyle=':')plt.plot(x, sinx, color='dodgerblue', label='sin(x)')plt.plot(x, cosx, color='orangered', label='cos(x)')plt.fill_between(x, sinx, cosx, sinx&lt;cosx, color='dodgerblue', alpha=.3)plt.fill_between(x, sinx, cosx, sinx&gt;cosx, color='orangered', alpha=.3)plt.legend()plt.savefig('fill_between.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>fill_between</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis: outer measure]]></title>
    <url>%2F2016%2F08%2F09%2Freal-analysis-outer-measure%2F</url>
    <content type="text"><![CDATA[两种方式从outer measure 到 lebesgue measure1: outer measure + inter measure2: outer measure]]></content>
  </entry>
  <entry>
    <title><![CDATA[real analysis: measure]]></title>
    <url>%2F2016%2F08%2F09%2Freal-analysis-measure%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2F2016%2F08%2F08%2Fvim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一些常用的vim快捷键（命令模式下）选中后 “+y(+也是按键) 复制到系统剪切板viw 选中光标所在的单词gg 到文档顶部G 到文档底部n,md 删除从n到m行u 撤销到上一步v 进入到visual模式dd 删除当前行yy 复制当前行b光标跳转到上一个单词w光标跳转到下一个单词:/要搜索的词 + 回车 搜索i insert模式 ，任意模式模式下按esc进入到命令模式o 移动到光标下一行并新建一行O 移动到光标上一行并新建一行$ 移动光标到行尾 ^ 移动光标到行首 缩进单行代码是两个大于号’&gt;&gt;’回缩就是两个小于号’&lt;&lt;’如果想要缩进很多行代码的话就按照下面做 1 //在这里按下’v’进入选择模式111111//光标移动到这里，再按一次大于号’&gt;’缩进一次，按’6&gt;’缩进六次，按’&lt;’回缩。以下同理 ：%s/vivian/sky/g（等同于：g/vivian/s//sky/g）替换每一行中所有 vivian 为 sky]]></content>
      <categories>
        <category>programming/linux/vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Foundations of Modern Analysis(Friedman 1970)]]></title>
    <url>%2F2016%2F08%2F08%2FFoundations-of-Modern-Analysis-Friedman-1970%2F</url>
    <content type="text"><![CDATA[download]]></content>
      <categories>
        <category>math/modern analysis</category>
      </categories>
      <tags>
        <tag>modern analysis</tag>
        <tag>real analysis</tag>
        <tag>functional analysis</tag>
        <tag>textbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis and functional analysis 讲义]]></title>
    <url>%2F2016%2F08%2F07%2Freal-analysis-and-functional-analysis%2F</url>
    <content type="text"><![CDATA[台交大吴培元real-analysis-class1.pdfreal-analysis-class10.pdfreal-analysis-class11.pdfreal-analysis-class12.pdfreal-analysis-class13.pdfreal-analysis-class14.pdfreal-analysis-class15.pdfreal-analysis-class16.pdfreal-analysis-class17.pdfreal-analysis-class18.pdfreal-analysis-class19-20.pdfreal-analysis-class2.pdfreal-analysis-class21.pdfreal-analysis-class22.pdfreal-analysis-class23-24.pdfreal-analysis-class25.pdfreal-analysis-class26.pdfreal-analysis-class27.pdfreal-analysis-class28.pdfreal-analysis-class29.pdfreal-analysis-class3.pdfreal-analysis-class30.pdfreal-analysis-class31.pdfreal-analysis-class32.pdfreal-analysis-class33.pdfreal-analysis-class34.pdfreal-analysis-class35.pdfreal-analysis-class36.pdfreal-analysis-class37.pdfreal-analysis-class38.pdfreal-analysis-class39.pdfreal-analysis-class4.pdfreal-analysis-class40.pdfreal-analysis-class41.pdfreal-analysis-class42.pdfreal-analysis-class43.pdfreal-analysis-class44.pdfreal-analysis-class45-46.pdfreal-analysis-class47.pdfreal-analysis-class48.pdfreal-analysis-class49.pdfreal-analysis-class5.pdfreal-analysis-class50.pdfreal-analysis-class52.pdfreal-analysis-class53.pdfreal-analysis-class54-56.pdfreal-analysis-class57.pdfreal-analysis-class58.pdfreal-analysis-class59.pdfreal-analysis-class6.pdfreal-analysis-class60.pdfreal-analysis-class61.pdfreal-analysis-class62.pdfreal-analysis-class63.pdfreal-analysis-class64.pdfreal-analysis-class65.pdfreal-analysis-class66.pdfreal-analysis-class67.pdfreal-analysis-class68.pdfreal-analysis-class69.pdfreal-analysis-class7.pdfreal-analysis-class8.pdfreal-analysis-class9.pdf課程內容.txt]]></content>
      <categories>
        <category>math/real and functional analysis</category>
      </categories>
      <tags>
        <tag>real analysis</tag>
        <tag>functional analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim插件管理器vundle]]></title>
    <url>%2F2016%2F08%2F07%2Fvim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8vundle%2F</url>
    <content type="text"><![CDATA[安装 Vundle 由于 vim 缺乏默认的插件管理器，所有插件的文件都散布在 ~/.vim 下的几个文件夹中，这样导致各种插件的安装、更新、删除都需要自己手动处理，既麻烦费事，又可能出现错误。所以我们需要插件管理器的帮忙，常见的插件管理器有 vundle、pathogen 等等，我们这里使用 vundle。 Vundle 托管在 Github 上，所以使用 git 下载 vundle ，并将其存放于 ~/.vim/bundle/vundle 即可。使用如下命令直接将源代码检出到该目录： 1$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 下载完了 vundle 后，还需要配置 .vimrc 文件。 为了不让 .vimrc 看起来太臃肿，我是新建了一个 ~/.vimrc.bundles 文件来保存所有插件的配置。先在 ~/.vimrc.bundles 文件中包含如下内容： 123filetype off set rtp+=~/.vim/bundle/vundle/call vundle#rc() 然后在 ~/.vimrc 文件中加入内容： 12345678910111213141516171819202122232425262728293031323334353637383940if filereadable(expand("~/.vimrc.bundles")) source ~/.vimrc.bundlesendifset runtimepath^=~/.vim/bundle/ctrlp.vim filetype offset rtp+=~/.vim/bundle/vundle/call vundle#rc()filetype plugin indent on map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;set nu highlight LineNr cterm=bold ctermfg=redhighlight StorageClass cterm=bold ctermfg=darkgreenhighlight Type cterm=bold ctermfg=bluehighlight LineNr cterm=bold ctermbg=blackhighlight phpStructure cterm=bold ctermfg=darkredhighlight phpFunctions cterm=bold ctermfg=256highlight Title ctermfg=blue highlight pythonString cterm=bold ctermfg=grayhighlight pythonFunction cterm=bold highlight pythonInclude cterm=bold ctermfg=lightbluehighlight javaScriptStringS ctermfg=gray highlight String ctermfg=grayhi Search cterm=NONE ctermfg=darkred ctermbg=yellow cterm=reverse set hlsearchset backspace=2set rulerset showmodesyntax on set smartindent set tabstop=4 set shiftwidth=4 set expandtab set softtabstop=4 安装插件以“用户名/repos名”的方式。我们这里将插件的配置信息放在 ~/.vimrc.bundles，如下： 12345678910111213141516171819202122232425262728293031323334353637383940filetype off set rtp+=~/.vim/bundle/vundle/call vundle#rc()&quot; Define bundles via Github repos &quot;Bundle &apos;christoomey/vim-run-interactive&apos;Bundle &apos;Valloric/YouCompleteMe&apos;Bundle &apos;croaky/vim-colors-github&apos;Bundle &apos;danro/rename.vim&apos;Bundle &apos;majutsushi/tagbar&apos;Bundle &apos;kchmck/vim-coffee-script&apos;Bundle &apos;kien/ctrlp.vim&apos;Bundle &apos;pbrisbin/vim-mkdir&apos;Bundle &apos;scrooloose/syntastic&apos;Bundle &apos;slim-template/vim-slim&apos;Bundle &apos;thoughtbot/vim-rspec&apos;Bundle &apos;tpope/vim-bundler&apos;Bundle &apos;tpope/vim-endwise&apos;Bundle &apos;tpope/vim-fugitive&apos;Bundle &apos;tpope/vim-rails&apos;Bundle &apos;tpope/vim-surround&apos;Bundle &apos;vim-ruby/vim-ruby&apos;Bundle &apos;vim-scripts/ctags.vim&apos;Bundle &apos;vim-scripts/matchit.zip&apos;Bundle &apos;vim-scripts/tComment&apos;Bundle &apos;mattn/emmet-vim&apos;Bundle &apos;scrooloose/nerdtree&apos;Bundle &apos;Xuyuanp/nerdtree-git-plugin&apos;Bundle &apos;Lokaltog/vim-powerline&apos;Bundle &apos;godlygeek/tabular&apos;Bundle &apos;msanders/snipmate.vim&apos;Bundle &apos;jelera/vim-javascript-syntax&apos;Bundle &apos;altercation/vim-colors-solarized&apos;Bundle &apos;othree/html5.vim&apos;Bundle &apos;xsbeats/vim-blade&apos;Bundle &apos;Raimondi/delimitMate&apos;Bundle &apos;groenewege/vim-less&apos;&quot; Bundle &apos;evanmiller/nginx-vim-syntax&apos;Bundle &apos;Lokaltog/vim-easymotion&apos;Bundle &apos;tomasr/molokai&apos;Bundle &apos;klen/python-mode&apos; 接着，打开 vim，输入 :BundleInstall 或者直接在终端输入 vim +BundleInstall +qall 安装插件。 YouCompleteMe安装YouCompleteMe的步骤 用vundle中的安装太慢,所以自己手动安装检查是否安装clang、g++、cmake等安装插件管理工具 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在.vimrc中插件管理处加入: 'Valloric/YouCompleteMe'```12安装ycm cd .vim/bundlegit clone https://github.com/Valloric/YouCompleteMe.gitcd YouCompleteMegit submodule update –init –recursive./install.py –clang-completer 12这里安装子模块会出现 fatal: unable to access ‘https://go.googlesource.com/tools/&#39;: Failed to connect to go.googlesource.com port 443: 连接超时fatal: 无法克隆 ‘https://go.googlesource.com/tools&#39; 到子模组路径 ‘/home/zyj/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/x/tools’ 123原因 go.googlesource.com 域名国内无法直接访问，这时候根据 后面的路径 /home/zyj/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/x/tools 来知道该模块是要放这个路径下的到 github 上找到该模块下载到该路径 cd ~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/xgit clone https://github.com/golang/tools.git 12回到 YouComplateMe 目录继续安装其他子模块 cd ~/.vim/bundle/YouCompleteMe 继续子模块的安装git submodule update –init –recursive 122. 去一个你喜欢的目录，例如用户主目录 cd ~ 创建一个目录用来存放接下来要编译的代码的目录mkdir ~/.ycm_build 进入目录cd ~/.ycm_build 编译输出到当前目录(.ycm_build)1cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp 2.1 如果需要实用 C 语言家族的相关功能(我这里系统自带 llvm 3.8、clang 3.8、libclang 没有、libboost-all-dev 没有)，不需要则直接跳过 2.1 1sudo apt install llvm-3.9 clang-3.9 libclang-3.9-dev libboost-all-dev 2.2 编译 YouComplateMe 1# 跳过了 2.1 执行&lt;br&gt;cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp&lt;br&gt;&lt;b 在.vimrc中添加下列 1let g:ycm_global_ycm_extra_conf = &apos;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;]]></content>
      <categories>
        <category>programming/linux</category>
      </categories>
      <tags>
        <tag>linux vim vundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis 01 overrview]]></title>
    <url>%2F2016%2F08%2F06%2Freal-analysis-01-overrview%2F</url>
    <content type="text"><![CDATA[网址:http://v.youku.com/v_show/id_XMjM0Mjg3NDA4.html?f=5422309老师:台交大吴培元吴老师说：这个课听一遍就可以了，知道后续的理论是有基础的，后来的分析遇到了就翻阅相关内容。数学系所说的实变函数学十遍，听听就好。 分析的不同学习阶段，real analysie 位于第二阶段1 数学分析(微积分)2 实分析(实变函数、实变函数论)3 泛函分析 content:1/3 measure theory1/3 lebsgue integral1/3 probility theory Testbook Real Analysis and Functional analysis history measure Riemann integral Lebesgue integral Advantages of Lebesgue over Riemann1) more applicability2) unified theory3)4) fundamental them of Calculus probility theory]]></content>
      <categories>
        <category>math/real-analysis</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>real-analysis</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[conda的包路径查找]]></title>
    <url>%2F2019%2F08%2F12%2Fconda%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[如果找不到display路径可以通过envs/环境变量/conda-meta/mpld3-0.3-py35_0.json文件找到安装路径找到”paths_data”从而找到{ “path”: “lib/python3.5/site-packages/mpld3/__pycache/_display.cpython-35.pyc”, “path_type”: “hardlink”, “sha256”: “3cd28fc146c93bbb8e211212d4308494e210ccb56ece4976bc60bfef00cc1a27”, “sha256_in_prefix”: “3cd28fc146c93bbb8e211212d4308494e210ccb56ece4976bc60bfef00cc1a27”, “size_in_bytes”: 16226 },]]></content>
      <categories>
        <category>programming/python/conda</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>conda</tag>
        <tag>包路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpld3._display.NumpyEncoder报错]]></title>
    <url>%2F2019%2F08%2F12%2Fmpld3-display-NumpyEncoder%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[在使用mpld3.display.NumpyEncoder过程中报错 12345678910111213141516Traceback (most recent call last):File "ttt.py", line 55, in htmlfil.write(mpld3.fig_to_html(fig))File "/usr/local/lib/python2.7/dist-packages/mpld3/_display.py", line 251, in fig_to_htmlfigure_json=json.dumps(figure_json, cls=NumpyEncoder),File "/usr/lib/python2.7/json/init.py", line 250, in dumpssort_keys=sort_keys, **kw).encode(obj)File "/usr/lib/python2.7/json/encoder.py", line 207, in encodechunks = self.iterencode(o, _one_shot=True)File "/usr/lib/python2.7/json/encoder.py", line 270, in iterencodereturn _iterencode(o, 0)File "/usr/local/lib/python2.7/dist-packages/mpld3/_display.py", line 138, in defaultreturn json.JSONEncoder.default(self, obj)File "/usr/lib/python2.7/json/encoder.py", line 184, in defaultraise TypeError(repr(o) + " is not JSON serializable")TypeError: array([ 1.]) is not JSON serializable 可以在mpld3._display()中修改NumpyEncoder类使用anaconda3用户的包在下面这个位置/Users/用户名/anaconda3/envs/虚拟环境名/lib/python3.5/site-packages/mpld3 12345678910111213class NumpyEncoder(json.JSONEncoder): """ Special json encoder for numpy types """ def default(self, obj): if isinstance(obj, (numpy.int_, numpy.intc, numpy.intp, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16,numpy.uint32, numpy.uint64)): return int(obj) elif isinstance(obj, (numpy.float_, numpy.float16, numpy.float32, numpy.float64)): return float(obj) elif isinstance(obj,(numpy.ndarray,)): #### This is the fix return obj.tolist() return json.JSONEncoder.default(self, obj) 如果找不到_display路径可以通过envs/环境变量/conda-meta/mpld3-0.3-py35_0.json文件找到安装路径找到”paths_data”从而找到{&quot;_path&quot;: &quot;lib/python3.5/site-packages/mpld3/__pycache__/_display.cpython-35.pyc&quot;, &quot;path_type&quot;: &quot;hardlink&quot;, &quot;sha256&quot;: &quot;3cd28fc146c93bbb8e211212d4308494e210ccb56ece4976bc60bfef00cc1a27&quot;, &quot;sha256_in_prefix&quot;: &quot;3cd28fc146c93bbb8e211212d4308494e210ccb56ece4976bc60bfef00cc1a27&quot;, &quot;size_in_bytes&quot;: 16226 },]]></content>
      <categories>
        <category>programming/python/mpld3</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>mpld3</tag>
        <tag>_display</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协方差(相关性)、协整、回归系数]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%8D%8F%E6%96%B9%E5%B7%AE-%E7%9B%B8%E5%85%B3%E6%80%A7-%E3%80%81%E5%8D%8F%E6%95%B4%E3%80%81%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[线性回归、二元逻辑回归、多元逻辑回归的损失函数]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E3%80%81%E4%BA%8C%E5%85%83%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E3%80%81%E5%A4%9A%E5%85%83%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>economics/econometrics</category>
      </categories>
      <tags>
        <tag>linear regression</tag>
        <tag>logit regression</tag>
        <tag>multinomial logit regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用日常]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E4%BD%BF%E7%94%A8%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"></content>
      <categories>
        <category>programming/nodejs/hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>日常积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas read_table]]></title>
    <url>%2F2019%2F08%2F09%2Fpandas-read-table%2F</url>
    <content type="text"><![CDATA[pandas.read_csv参数详解pandas.read_csv参数整理 读取CSV（逗号分割）文件到DataFrame也支持文件的部分导入和选择迭代更多帮助参见：http://pandas.pydata.org/pandas-docs/stable/io.html参数： filepath_or_buffer : str，pathlib。str, pathlib.Path, py._path.local.LocalPath or any object with a read() method (such as a file handle or StringIO)可以是URL，可用URL类型包括：http, ftp, s3和文件。对于多文件正在准备中本地文件读取实例：://localhost/path/to/table.csv sep : str, default ‘,’指定分隔符。如果不指定参数，则会尝试使用逗号分隔。分隔符长于一个字符并且不是‘\s+’,将使用python的语法分析器。并且忽略数据中的逗号。正则表达式例子：’\r\t’ delimiter : str, default None定界符，备选分隔符（如果指定该参数，则sep参数失效） delim_whitespace : boolean, default False.指定空格(例如’ ‘或者’ ‘)是否作为分隔符使用，等效于设定sep=’\s+’。如果这个参数设定为Ture那么delimiter 参数失效。在新版本0.18.1支持 header : int or list of ints, default ‘infer’指定行数用来作为列名，数据开始行数。如果文件中没有列名，则默认为0，否则设置为None。如果明确设定header=0 就会替换掉原来存在列名。header参数可以是一个list例如：[0,1,3]，这个list表示将文件中的这些行作为列标题（意味着每一列有多个标题），介于中间的行将被忽略掉（例如本例中的2；本例中的数据1,2,4行将被作为多级标题出现，第3行数据将被丢弃，dataframe的数据从第5行开始。）。注意：如果skip_blank_lines=True 那么header参数忽略注释行和空行，所以header=0表示第一行数据而不是文件的第一行。 names : array-like, default None用于结果的列名列表，如果数据文件中没有列标题行，就需要执行header=None。默认列表中不能出现重复，除非设定参数mangle_dupe_cols=True。 index_col : int or sequence or False, default None用作行索引的列编号或者列名，如果给定一个序列则有多个行索引。如果文件不规则，行尾有分隔符，则可以设定index_col=False 来是的pandas不适用第一列作为行索引。 usecols : array-like, default None返回一个数据子集，该列表中的值必须可以对应到文件中的位置（数字可以对应到指定的列）或者是字符传为文件中的列名。例如：usecols有效参数可能是 [0,1,2]或者是 [‘foo’, ‘bar’, ‘baz’]。使用这个参数可以加快加载速度并降低内存消耗。 as_recarray : boolean, default False不赞成使用：该参数会在未来版本移除。请使用pd.read_csv(…).to_records()替代。返回一个Numpy的recarray来替代DataFrame。如果该参数设定为True。将会优先squeeze参数使用。并且行索引将不再可用，索引列也将被忽略。 squeeze : boolean, default False如果文件值包含一列，则返回一个Series prefix : str, default None在没有列标题时，给列添加前缀。例如：添加‘X’ 成为 X0, X1, … mangle_dupe_cols : boolean, default True重复的列，将‘X’…’X’表示为‘X.0’…’X.N’。如果设定为false则会将所有重名列覆盖。 dtype : Type name or dict of column -&gt; type, default None每列数据的数据类型。例如 {‘a’: np.float64, ‘b’: np.int32} engine : {‘c’, ‘python’}, optionalParser engine to use. The C engine is faster while the python engine is currently more feature-complete.使用的分析引擎。可以选择C或者是python。C引擎快但是Python引擎功能更加完备。 converters : dict, default None列转换函数的字典。key可以是列名或者列的序号。 true_values : list, default NoneValues to consider as True false_values : list, default NoneValues to consider as False skipinitialspace : boolean, default False忽略分隔符后的空白（默认为False，即不忽略）. skiprows : list-like or integer, default None需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）。 skipfooter : int, default 0从文件尾部开始忽略。 (c引擎不支持) skip_footer : int, default 0不推荐使用：建议使用skipfooter ，功能一样。 nrows : int, default None需要读取的行数（从文件头开始算起）。 na_values : scalar, str, list-like, or dict, default None一组用于替换NA/NaN的值。如果传参，需要制定特定列的空值。默认为‘1.#IND’, ‘1.#QNAN’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘nan’`. keep_default_na : bool, default True如果指定na_values参数，并且keep_default_na=False，那么默认的NaN将被覆盖，否则添加。 na_filter : boolean, default True是否检查丢失值（空字符串或者是空值）。对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度。 verbose : boolean, default False是否打印各种解析器的输出信息，例如：“非数值列中缺失值的数量”等。 skip_blank_lines : boolean, default True如果为True，则跳过空行；否则记为NaN。 parse_dates : boolean or list of ints or names or list of lists or dict, default Falseboolean. True -&gt; 解析索引list of ints or names. e.g. If [1, 2, 3] -&gt; 解析1,2,3列的值作为独立的日期列；list of lists. e.g. If [[1, 3]] -&gt; 合并1,3列作为一个日期列使用dict, e.g. {‘foo’ : [1, 3]} -&gt; 将1,3列合并，并给合并后的列起名为”foo” infer_datetime_format : boolean, default False如果设定为True并且parse_dates 可用，那么pandas将尝试转换为日期类型，如果可以转换，转换方法并解析。在某些情况下会快5~10倍。 keep_date_col : boolean, default False如果连接多列解析日期，则保持参与连接的列。默认为False。 date_parser : function, default None用于解析日期的函数，默认使用dateutil.parser.parser来做转换。Pandas尝试使用三种不同的方式解析，如果遇到问题则使用下一种方式。1.使用一个或者多个arrays（由parse_dates指定）作为参数；2.连接指定多列字符串作为一个列作为参数；3.每行调用一次date_parser函数来解析一个或者多个字符串（由parse_dates指定）作为参数。 dayfirst : boolean, default FalseDD/MM格式的日期类型 iterator : boolean, default False返回一个TextFileReader 对象，以便逐块处理文件。 chunksize : int, default None文件块的大小， See IO Tools docs for more informationon iterator and chunksize. compression : {‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’直接使用磁盘上的压缩文件。如果使用infer参数，则使用 gzip, bz2, zip或者解压文件名中以‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’这些为后缀的文件，否则不解压。如果使用zip，那么ZIP包中国必须只包含一个文件。设置为None则不解压。新版本0.18.1版本支持zip和xz解压 thousands : str, default None千分位分割符，如“，”或者“.” decimal : str, default ‘.’字符中的小数点 (例如：欧洲数据使用’，‘). float_precision : string, default NoneSpecifies which converter the C engine should use for floating-point values. The options are None for the ordinary converter, high for the high-precision converter, and round_trip for the round-trip converter.指定 lineterminator : str (length 1), default None行分割符，只在C解析器下使用。 quotechar : str (length 1), optional引号，用作标识开始和解释的字符，引号内的分割符将被忽略。 quoting : int or csv.QUOTE_* instance, default 0控制csv中的引号常量。可选 QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3) doublequote : boolean, default True双引号，当单引号已经被定义，并且quoting 参数不是QUOTE_NONE的时候，使用双引号表示引号内的元素作为一个元素使用。 escapechar : str (length 1), default None当quoting 为QUOTE_NONE时，指定一个字符使的不受分隔符限值。 comment : str, default None标识着多余的行不被解析。如果该字符出现在行首，这一行将被全部忽略。这个参数只能是一个字符，空行（就像skip_blank_lines=True）注释行被header和skiprows忽略一样。例如如果指定comment=’#’ 解析‘#empty\na,b,c\n1,2,3’ 以header=0 那么返回结果将是以’a,b,c’作为header。 encoding : str, default None指定字符集类型，通常指定为’utf-8’. List of Python standard encodings dialect : str or csv.Dialect instance, default None如果没有指定特定的语言，如果sep大于一个字符则忽略。具体查看csv.Dialect 文档 tupleize_cols : boolean, default FalseLeave a list of tuples on columns as is (default is to convert to a Multi Index on the columns) error_bad_lines : boolean, default True如果一行包含太多的列，那么默认不会返回DataFrame ，如果设置成false，那么会将改行剔除（只能在C解析器下使用）。 warn_bad_lines : boolean, default True如果error_bad_lines =False，并且warn_bad_lines =True 那么所有的“bad lines”将会被输出（只能在C解析器下使用）。 low_memory : boolean, default True分块加载到内存，再低内存消耗中解析。但是可能出现类型混淆。确保类型不被混淆需要设置为False。或者使用dtype 参数指定类型。注意使用chunksize 或者iterator 参数分块读入会将整个文件读入到一个Dataframe，而忽略类型（只能在C解析器中有效） buffer_lines : int, default None不推荐使用，这个参数将会在未来版本移除，因为他的值在解析器中不推荐使用 compact_ints : boolean, default False不推荐使用，这个参数将会在未来版本移除如果设置compact_ints=True ，那么任何有整数类型构成的列将被按照最小的整数类型存储，是否有符号将取决于use_unsigned 参数 use_unsigned : boolean, default False不推荐使用：这个参数将会在未来版本移除如果整数列被压缩(i.e. compact_ints=True)，指定被压缩的列是有符号还是无符号的。memory_map : boolean, default False如果使用的文件在内存内，那么直接map文件使用。使用这种方式可以避免文件再次进行IO操作。https://blog.csdn.net/u012131430/article/details/78299582]]></content>
  </entry>
  <entry>
    <title><![CDATA[商品期货协整配对]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%95%86%E5%93%81%E6%9C%9F%E8%B4%A7%E5%8D%8F%E6%95%B4%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[https://uqer.io/v3/community/share/57b52ac0228e5b79aa759416]]></content>
  </entry>
  <entry>
    <title><![CDATA[平稳性检验]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B9%B3%E7%A8%B3%E6%80%A7%E6%A3%80%E9%AA%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python模块: deque]]></title>
    <url>%2F2019%2F08%2F09%2Fpython%E6%A8%A1%E5%9D%97-deque%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[为markdown创建一个新标记符]]></title>
    <url>%2F2019%2F08%2F04%2F%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[问题的由来当我们在编写markdown文件的时候会经常从网页上ctr+c其他人的文字，而我们标注作者和文章的来源不是特别方便，这会导致许多时候我们不去标注作者和文章的来源。引文规范对于问题追溯和文明发展相当重要，与其道德说教来让大家遵守引文规范，不如提供更方便的方式来让大家遵守，因此，本文抛砖引玉出一种新的高效的规范和工具。 复制时天生携带引文信息将下面的javascript语句放到网页的head处 1234567891011121314&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt; 示例如下 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;测试1&lt;br&gt;测试2&lt;/body&gt;&lt;/html&gt; 当我们运行网页，复制网页中内容后，将其粘贴到mardown文件，会得到下面的结果 而其（在vscode+MarkDownPreview中）渲染成html的显示效果如下图这样我们就可以在不影响显示的情况下保留其引文信息。当然，html中保留引文信息的工作需要在markdown文件转换为html文件的过程中完成，转换工具和规范这里不做讨论，先留下个坑，或者其他人来完成吧，😃。 hexo的next主题下复制时附加引文信息找到hexo项目根目录，我的根目录是/blog在 ../blog/themes/next/layout/_partials/head目录下找到custom-head.swig文件，将下面的代码添加到文末就可以了。 1234567891011121314&lt;script type="text/javascript"&gt; document.addEventListener("copy", copy); function copy(oEvent)&#123; var selection = window.getSelection(); var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext); &#125;&lt;/script&gt; 将hexo-next下的文末出处去掉将文件../blog/themes/next/_config.yml（blog为我的hexo根目录）中的post_copyright项下的enable的值从true改为false 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 改完后为 12345# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 之后文章末尾就不会再出现下图的情形了 如果使用了代码复制功能怎么改当使用代码复制功能的时候，我们希望复制到干净的代码，却不想得到引用信息;而在复制文章内容的时候，我们希望得到引文信息。 笔者使用的是这个链接下实现的代码复制功能，https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%89/ 我的办法是：将clipboard-use.js文件的代码进行了一下升级，加了if语句。可以理解成将custom-head.swig文件里的那个添加引用的代码整合到了clipboard-use.js文件里。 1234567891011121314151617181920212223242526272829303132333435363738394041 /*页面载入完成后，创建复制按钮*/var btnCopyEmpty = true;document.addEventListener("copy", copy);function copy(oEvent)&#123; var selection = window.getSelection(); if(btnCopyEmpty)&#123; console.log(btnCopyEmpty) var quoteMagic = "&lt;!-- It's convenient in markdown file. --&gt;\n"; quoteMagic += "&lt;!-- More information: https://www.exobrain.online/2019/08/04/%E4%B8%BAmarkdown%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E6%96%87%E6%A0%87%E8%AE%B0%E7%AC%A6/#more --&gt;\n"; quoteMagic += "&lt;!-- quote(start)&#123; author: authorname, site: www.sitename.com, location: "; quoteMagic += document.location.href; quoteMagic += "&#125; --&gt;\n"; var copytext = quoteMagic + selection + "\n&lt;!-- quote(end) --&gt;"; &#125;else&#123; var copytext = selection; &#125; oEvent.preventDefault(); oEvent.clipboardData.setData("text", copytext);&#125;;!function (e, t, a) &#123; /* code */var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; btnCopyEmpty = false; return trigger.nextElementSibling; &#125; &#125;); // clipboard.on('success', function(e)&#123; // btnCopyEmpty = false; // &#125;);&#125;initCopyCode();&#125;(window, document);]]></content>
      <categories>
        <category>programming/nodejs/hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>javascript</tag>
        <tag>quote</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test password]]></title>
    <url>%2F2019%2F08%2F04%2Ftest-password%2F</url>
    <content type="text"></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot:dates]]></title>
    <url>%2F2016%2F08%2F12%2Fmatplotlib-pyplot-dates%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152""" demo12_loadtxt.py aapl.csv文件读取"""import numpy as npimport datetime as dtimport matplotlib.pyplot as pltimport matplotlib.dates as mddef dmy2ymd(dmy): dmy = str(dmy, encoding='utf-8') time = dt.datetime.strptime(dmy, '%d-%m-%Y').date() t = time.strftime('%Y-%m-%d') return t# dtype中的dates为M8[D], &lt;class 'numpy.ndarray'&gt;dates, opening_prices, highest_prices,\ lowest_prices, closing_prices = np.loadtxt( '../data/aapl.csv', delimiter=',', usecols=(1, 3, 4, 5, 6), unpack=True, dtype='M8[D], f8, f8, f8, f8', converters=&#123;1: dmy2ymd&#125; # 转换器函数)# 绘制收盘价折线图plt.figure('AAPL K', facecolor='lightgray')plt.title('AAPL K', fontsize=16)plt.xlabel('Day', fontsize=14)plt.ylabel('Price', fontsize=14)plt.tick_params(labelsize=10)plt.grid(linestyle=':')# 为了日期显示合理，修改dates的dtypedates = dates.astype(md.datetime.datetime)# 设置x轴刻度定位器ax = plt.gca()#设置主刻度定位器为周定位器（每周一显示主刻度文本）ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))ax.xaxis.set_major_formatter(md.DateFormatter('%d %b %Y'))#设置次刻度定位器为日定位器ax.xaxis.set_minor_locator(md.DayLocator())plt.tick_params(labelsize=8)plt.plot(dates, closing_prices, color='dodgerblue', linewidth=2, linestyle='--', label='AAPL CP')plt.legend()plt.gcf().autofmt_xdate()plt.savefig('Apple_stock_prices_with_dates.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>dates</tag>
        <tag>loadtxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.FuncAnimation:data_generator]]></title>
    <url>%2F2016%2F08%2F12%2Fmatplotlib-pyplot-FuncAnimation-data-generator%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npimport matplotlib.pyplot as pltimport matplotlib.animation as maplt.figure("Signal", facecolor='lightgray')plt.title("Signal", fontsize=14)plt.xlim(0, 10)plt.ylim(-3, 3)plt.grid(linestyle='--', color='lightgray', alpha=0.5)pl = plt.plot([], [], color='dodgerblue', label='Signal')[0]pl.set_data([],[])x = 0def y_generator(): global x while True: y = np.sin(2 * np.pi * x) * np.exp(np.sin(0.2 * np.pi * x)) yield (x, y) x += 0.05data = y_generator()t, v = [], []def update(i): print(i) global data x, y = next(data) t.append(x) v.append(y) #重新设置数据源 pl.set_data(t, v) #移动坐标轴 if(t[-1]&gt;10): plt.xlim(t[-1]-10, t[-1])# save_count为缓存的帧数，# frames 为帧数如果是可迭代对象，可迭代对象的长度将覆盖save_count参数anim = ma.FuncAnimation(plt.gcf(), update, frames=400, interval=40)plt.tight_layout()anim.save('Signal_animation.gif', fps=75,writer='imagemagick')# 如果show 必须放在save后面plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>animation</tag>
        <tag>FuncAnimation</tag>
        <tag>data_generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.animation.FuncAnimation]]></title>
    <url>%2F2016%2F08%2F12%2Fmatplotlib-animation-FuncAnimation%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport matplotlib.pyplot as pltimport matplotlib.animation as ma# 初始化构建所有样本n = 100balls = np.zeros(n, dtype=[ ('position', float, 2), ('size', float, 1), ('growth', float, 1), ('color', float, 4)])balls['position'] = np.random.uniform(0, 1, (n, 2))balls['size'] = np.random.uniform(40, 50, n)balls['growth'] = np.random.uniform(10, 20, n)balls['color'] = np.random.uniform(0, 1, (n, 4))# 绘制图像plt.figure('Bubble', facecolor='lightgray')plt.title('Bubble', fontsize=16)sc = plt.scatter(balls['position'][:, 0], balls['position'][:, 1], balls['size'], color=balls['color'])plt.xticks([])plt.yticks([])# 实现动画def update(number): # 更新界面, 让每个点不断变大 balls['size'] += balls['growth'] sc.set_sizes(balls['size']) index = number % n balls['size'][index] = \ np.random.uniform(40, 70, 1) balls['position'][index] = \ np.random.uniform(0, 1, (1, 2)) # 更新界面 sc.set_sizes(balls['size']) sc.set_offsets(balls['position'])# 每隔三十毫秒，执行一次update函数# 使用imagemagick 保存为gif# 提前 sudo apt-get install imagemagickanim = ma.FuncAnimation( plt.gcf(), update, interval=30, save_count=50)anim.save('bubble_animation.gif',fps=500, writer='imagemagick')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>animation</tag>
        <tag>FuncAnimation</tag>
        <tag>imagemagick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数getitem系列]]></title>
    <url>%2F2016%2F08%2F12%2Fpython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0getitem%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[123456789101112131415class DictDemo: def __init__(self,key,value): self.dict = &#123;&#125; self.dict[key] = value def __getitem__(self,key): return self.dict[key] def __setitem__(self,key,value): self.dict[key] = value def __len__(self): return len(self.dict)dictDemo = DictDemo('key0','value0')print(dictDemo['key0']) #value0dictDemo['key1'] = 'value1'print(dictDemo['key1']) #value1print(len(dictDemo)) #2]]></content>
      <categories>
        <category>programming/python/内置函数</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内置函数</tag>
        <tag>getitem</tag>
        <tag>setitem</tag>
        <tag>len</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[from eval to getattr hasattr setattr]]></title>
    <url>%2F2016%2F08%2F12%2Ffrom%20eval%20to%20getattr%20hasattr%20setattr%2F</url>
    <content type="text"><![CDATA[现实中的问题：我手中有一个列表[（’请求网页’,’网页1’）,（’解析网页’,’网页1’, (‘保存网页’, ‘网页1’),’请求网页’,’网页2’）,（’解析网页’,’网页2’, (‘保存网页’, ‘网页2’),… ]，想将列表中的事情从头到尾都干一遍。 首先，定义一个类 1234567class Spider: def request(self, page): print('请求网页:', page) def parse(self, page): print('解析网页:', page) def save(self, page): print('保存网页:', page) 然后我们想的是，如何复用Spider里的方法许多人的做法是直接使用eval做法如下 12345todo_lst = [('request', 'www.exobrain.online'), ('parse', 'www.exobrain.online'), ('save', 'www.exobrain.online'),('request', 'www.exobrain.online/categories/'), ('parse', 'www.exobrain.online/categories/'), ('save', 'www.exobrain.online/categories/'), ('方法测试1','www.exobrain.online/categories/')]spider = Spider()for item in todo_lst: string = 'spider.' + item[0]+'("'+item[1]+'")' eval(string) 出来了结果 123456789请求网页: www.exobrain.online解析网页: www.exobrain.online保存网页: www.exobrain.online请求网页: www.exobrain.online/categories/解析网页: www.exobrain.online/categories/保存网页: www.exobrain.online/categories/...AttributeError: &apos;Spider&apos; object has no attribute &apos;错误的方法测试1&apos;(报错：部分) 我们看到了报错，自然可以用try except处理。but，eval is evil, it’s not suggested. If you use eval, python is no longer elegant.So, we introduce the inbuit methods “getattr, hasattr, setattr“（参考自https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string不得不感慨国内外的差距，人家11years前解决的问题，我们到现在还有好多程序员处于问题之中，还在大量使用eval()。） 使用getattr代替eval, 将for部分注释掉重写如下 1234567891011todo_lst = [('request', 'www.exobrain.online'), ('parse', 'www.exobrain.online'), ('save', 'www.exobrain.online'),('request', 'www.exobrain.online/categories/'), ('parse', 'www.exobrain.online/categories/'), ('save', 'www.exobrain.online/categories/'), ('方法测试1','www.exobrain.online/categories/')]spider = Spider()# for item in todo_lst:# string = 'spider.' + item[0]+'("'+item[1]+'")'# eval(string)for item in todo_lst: if not hasattr(spider, item[0]): print('Spider类里不存在方法:', item[0]) continue getattr(spider, item[0])(item[1]) 我们看到了漂亮的结果，有没有发现上面的hasattr+getattr的代码比eval的代码更加优雅。I choose getattr instead of eval just because of elegance. 😃 1234567请求网页: www.exobrain.online解析网页: www.exobrain.online保存网页: www.exobrain.online请求网页: www.exobrain.online/categories/解析网页: www.exobrain.online/categories/保存网页: www.exobrain.online/categories/Spider类里不存在方法: 方法测试1 动态将函数添加到类或者对象里面 12345678910111213141516171819202122def method_added(page): print('调用method_added函数',page)# 将method_added 注册到spider对象里setattr(spider, 'method_added', method_added)# 测试method_added是否添加到spider对象里print(hasattr(spider, 'method_added'))# &gt;True 返回值为True, 添加成功getattr(spider, 'method_added')('www.exobrain.online')# &gt; 调用method_added函数 www.exobrain.onlinedef method_added2(self, page): print('调用method_added2函数',page)# 将method_added2 注册到Spider类里setattr(Spider, 'method_added2', method_added2)# 测试method_added是否添加到spider对象里print(hasattr(spider, 'method_added2'))# &gt;True 返回值为True, 添加成功getattr(spider, 'method_added2')('www.exobrain.online')# &gt; 调用method_added函数 www.exobrain.online 对于函数调用怎么办？我们可以使用locals 和 globals。locals() 和 globals() 是python的两个内置函数，通过它们可以一字典的方式访问局部和全局变量。 1234567891011121314151617def foo(): print "foo"def bar(): print "bar"func_list = ["foo","bar"]for func in func_list: locals()[func]()# &gt;foo# &gt;barfor func in func_list: globals()[func]()# &gt;foo# &gt;bar 参考：https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string]]></content>
      <categories>
        <category>programming/python/内置函数</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>eval</tag>
        <tag>getattr</tag>
        <tag>hasattr</tag>
        <tag>setattr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[foo and bar 是个啥？]]></title>
    <url>%2F2016%2F08%2F12%2Ffoo-and-bar-%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[foo &lt;– fu &lt;– fuck up 一团糟bar &lt;– beyond all recognition![foo_and_bar.jpg]foo_and_bar.jpg]]></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.gca:polar]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-gca-polar%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021""" demo09_3d_polar.py 3d 极坐标系"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据t = np.linspace(0, 4*np.pi, 1000)r = 0.8 * t# 绘制plt.figure('3D Polar', facecolor='lightgray')plt.title('3D Polar', fontsize=18)ax3d = plt.gca(projection='polar')ax3d.set_xlabel(r'$\theta$', fontsize=14)ax3d.set_ylabel(r'$\rho$', fontsize=14)plt.tick_params(labelsize=10)plt.grid(linestyle=':')plt.plot(t, r)plt.savefig('3d_polar.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>polar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot_wireframe]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-plot-wireframe%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930""" demo07_3d_wireframe.py 3d 曲面图"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制plt.figure('3D surface', facecolor='lightgray')plt.title('3D Surface', fontsize=18)ax3d = plt.gca(projection='3d') # class axes3dax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)ax3d.plot_wireframe(x, y, z, cmap='jet', rstride=30, cstride=30)plt.tick_params(labelsize=10)# set spines invisible for error of tight_layout()for spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.savefig('3d_wireframe.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>plot_wireframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot_surface]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-plot-surface%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233""" demo07_3dsurface.py 3d 曲面图"""import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dimport numpy as np# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制plt.figure('3D surface', facecolor='lightgray')plt.title('3D Surface', fontsize=18)ax3d = plt.gca(projection='3d')ax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)ax3d.plot_surface(x, y, z, cmap='jet', rstride=30, # 行跨距 cstride=30) # 列跨距plt.tick_params(labelsize=10)# set unused spines invisible to fix error of tight_layoutfor spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>plot_surface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.3dscatter]]></title>
    <url>%2F2016%2F08%2F11%2Fmatplotlib-pyplot-3dscatter%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930""" demo06_3dscatter.py 3D图"""import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dn = 300x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)z = np.random.normal(0, 1, n)# 绘制三维散点图plt.figure('3D Scatter', facecolor='lightgray')ax3d = plt.gca(projection='3d') # 创建三维坐标系plt.title('3D Scatter', fontsize=20)ax3d.set_xlabel('x', fontsize=14)ax3d.set_ylabel('y', fontsize=14)ax3d.set_zlabel('z', fontsize=14)plt.xticks([-3, -2, -1, 0, 1, 2, 3])plt.yticks([-3, -2, -1, 0, 1, 2, 3])plt.tick_params(labelsize=9)d = np.sqrt(x**2 + y**2 + z**2)ax3d.scatter(x, y, z, marker='o', s=70, c=d, alpha=.5, cmap='jet')# make unused spines invisible to fix error of tight_layoutfor spine in ax3d.spines.values(): spine.set_visible(False)plt.tight_layout()plt.savefig('3d-scatter.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>3dscatter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交易频率]]></title>
    <url>%2F2016%2F08%2F09%2F%E4%BA%A4%E6%98%93%E9%A2%91%E7%8E%87%2F</url>
    <content type="text"><![CDATA[首先，在交易之前你必须明确每个模型位于交易频谱的哪个频段。以下图为例，股指期货500毫秒级（指行情切片，并非交易频率）的跨期套利属于次高频，这是目前中国市场的天花板；题主所谓的中低频统计套利，应该分布在准低频、次低频以及次长仓的部分。频谱不同位置的模型相关性很低，在组合管理时甚至有对冲之效。所以不存在因为高频套利导致中低频机会减少的状况。link 其次，我们一般从三个维度去考量一个交易模型：盈利，风险，容量。 盈利比较常见的指标是 Annualized Return，风险比较常见的指标是 Maximum Drawdown，也有复合型的比如 Sharpe Ratio，Calmar Ratio，等等。容量则是指该模型所能管理的最大资金规模。在传统的“弱有效市场”假设下，这三个维度的要求无法在单一策略中全部满足。所以我们通常会牺牲其一： 你想要盈利高、容量大，则必须承受不小风险，比如动量类，被认为助涨助跌的趋势策略等；你想要风险低、容量大，则收益率很难上得去，比如机构最流行的期现套利、阿尔法套利等；你想要盈利高、风险低，则不可能容纳大资金，比如题主所说的高频跨期套利。举个例子，股指期货早期的市场微观结构非常粗糙，某个高频模型可以管理2000万人民币左右，平均每天的毛利率约为1%，纯利润大概在2~3‰（由于交易次数多，几乎无单日亏损）；也就是说，每天可以稳定地套到20万左右的毛利，其中约15万作为手续费上缴交易所，自己留下5万养矿工，养码农，必要时还要养监管层的朋友。但随着争夺套利机会的交易者日渐增多，该模型不仅寿命缩短（平均一个月就需要大修），而且管理规模也锐减到数百万的量级，基本相当于残废的水平。如果我想继续用它来管理2000万的账户，则必须付出收益率大幅下降的代价。这就是之前所说的此消彼长。 按照上述归类标准，中低频统计套利属于盈利高、风险大、容量大的策略类型，与高频套利不在同一个次元。假设单笔胜率同为70%，高频每天交易上千笔，根据大数定律，单日胜率几乎收敛到1；而中低频几天做一笔，遇到价差的结构性变化时难免资金回撤，但赚到一笔的利润胜过高频千笔。 正是对这些利润的追求，保证了股指期货各合约之间的价差不会出现大幅的非理性偏离：高频消灭微观上的偏离，而中低频消灭宏观上的偏离。他们各司其职，互相尊重，互不干涉内政。不过话说回来，现在最流行的政治正确，就是高频搞乱了市场，制造了恐慌，必须杀无赦，斩立决。所以题主你如果非要说高频套利太多，导致中低频的机会减少，似乎也并没有什么不对。以上 作者：王不二链接：https://www.zhihu.com/question/33792270/answer/58689716来源：知乎]]></content>
      <categories>
        <category>finance/hedging/concept</category>
      </categories>
      <tags>
        <tag>传统套利</tag>
        <tag>统计套利</tag>
        <tag>趋势套利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传统套利、统计套利、趋势套利]]></title>
    <url>%2F2016%2F08%2F09%2F%E4%BC%A0%E7%BB%9F%E5%A5%97%E5%88%A9%E3%80%81%E7%BB%9F%E8%AE%A1%E5%A5%97%E5%88%A9%E3%80%81%E8%B6%8B%E5%8A%BF%E5%A5%97%E5%88%A9%2F</url>
    <content type="text"><![CDATA[传统套利(无风险套利) 传统套利包括价差交易和对冲交易两种类型。统计套利 统计套利是只针对有稳定性的价格关系进行的。 那些没有稳定性的价格关系的套利风险是很大的。价格关系是否稳定直接决定着统计套利能否成立，因此在对价格关系的历史数据进行统计分析的时候，首先要检验价格关系在历史数据中是否稳定。一组价格关系如果是稳定的，那么必定是存在着某一种均衡关系维持机制，一旦价格关系偏离均衡水平，维持机制就会起作用，将价格关系或快或慢地拉回到均衡水平。趋势套利 统计套利和趋势追踪正好是相反的交易理念，趋势追踪讲究只追踪不预测，而统计套利则是从历史数据分析出数据规律，认为该规律会继续延续，对未来进行预测，并通过计算出数据分布的概率来确定交易时机有协整关系的两个标的，价差价比不但有回归特性也可能有趋势特性，也自然的因为品种特性的不同，有的品种趋势特性偏强，而有的品种回归特性偏强 http://blog.sina.com.cn/s/blog_4e08635b0102xv18.html]]></content>
      <categories>
        <category>finance/hedging/concept</category>
      </categories>
      <tags>
        <tag>传统套利</tag>
        <tag>统计套利</tag>
        <tag>趋势套利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.pie]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-pie%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122""" demo03_pie.py 饼状图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据labels = ['Python', 'JavaScript', 'C++', 'Java', 'PHP']values = [26, 17, 21, 29, 11]spaces = [0.05, 0.01, 0.01, 0.01, 0.01]colors = ['dodgerblue', 'orangered', 'limegreen', 'violet', 'gold']plt.figure('pie', facecolor='lightgray')# title 不显示中文plt.title(r'Pie Figure')# 等轴比例plt.axis('equal')plt.pie(values, spaces, labels, colors, '%.2f%%', shadow=True, startangle=0, radius=1)plt.savefig('Pie.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>pie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.contour]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-contour%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526""" demo04_contour.py 绘制等高线图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制等高线plt.figure('Contour', facecolor='lightgray')plt.title('Contour', fontsize=18)plt.grid(linestyle=':')cntr = plt.contour(x, y, z, 8, colors='black', linewidths=.5)# 绘制等高线的高度标签文本# inline_spacing 空白间距plt.clabel(cntr, inline_spacing=1, fmt='%.2f', fontsize=10)# 填充等高线plt.contourf(x, y, z, 8, cmap='jet')plt.savefig('Contour.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>contour</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.imshow]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-imshow%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021""" demo04_imshow.py 绘制热成像图"""import numpy as npimport matplotlib.pyplot as plt# 整理数据n = 500x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))# print(x, y)# 计算每个坐标点的高度z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)# 绘制等高线plt.figure('Imshow', facecolor='lightgray')plt.title('Imshow', fontsize=18)plt.grid(linestyle=':')plt.imshow(z, cmap='jet', origin='lower')plt.colorbar()plt.savefig('Imshow.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>imshow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.plot]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-plot%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.scatter]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-scatter%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.bar]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-bar%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltapples = np.array([91, 86, 23, 89, 45, 62, 39, 84, 88, 99, 21, 33])oranges = np.array([94, 59, 23, 21, 36, 91, 26, 23, 12, 199, 33, 44])plt.figure('Bar Chart', facecolor='lightgray')plt.title('Bar Chart', fontsize=18)plt.xlabel('Month', fontsize=16)plt.ylabel('Volume', fontsize=16)plt.tick_params(labelsize=10)plt.grid(linestyle=':')x = np.arange(1, 13)plt.bar(x-0.2, apples, .4,color='dodgerblue', label='Apple')plt.bar(x+0.2, oranges, .4,color='orangered', label='Orange')# 修改x的刻度文本plt.xticks(x, ['Jan', 'Feb', 'Mar', 'Apr', 'Mar', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])plt.legend()plt.savefig('Bar.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>bar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib.pyplot.fill_between]]></title>
    <url>%2F2016%2F08%2F09%2Fmatplotlib-pyplot-fill-between%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324""" demo_01_fill.py plot里的填充"""import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 8*np.pi, 1000)sinx = np.sin(x)cosx = np.cos(x/2)/2plt.figure('Fill', facecolor='lightgray')plt.title('Fill', fontsize=18)plt.grid(linestyle=':')plt.plot(x, sinx, color='dodgerblue', label='sin(x)')plt.plot(x, cosx, color='orangered', label='cos(x)')plt.fill_between(x, sinx, cosx, sinx&lt;cosx, color='dodgerblue', alpha=.3)plt.fill_between(x, sinx, cosx, sinx&gt;cosx, color='orangered', alpha=.3)plt.legend()plt.savefig('fill_between.png')plt.show()]]></content>
      <categories>
        <category>programming/python/matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyplot</tag>
        <tag>fill_between</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis: outer measure]]></title>
    <url>%2F2016%2F08%2F09%2Freal-analysis-outer-measure%2F</url>
    <content type="text"><![CDATA[两种方式从outer measure 到 lebesgue measure1: outer measure + inter measure2: outer measure]]></content>
  </entry>
  <entry>
    <title><![CDATA[real analysis: measure]]></title>
    <url>%2F2016%2F08%2F09%2Freal-analysis-measure%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2F2016%2F08%2F08%2Fvim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一些常用的vim快捷键（命令模式下）选中后 “+y(+也是按键) 复制到系统剪切板viw 选中光标所在的单词gg 到文档顶部G 到文档底部n,md 删除从n到m行u 撤销到上一步v 进入到visual模式dd 删除当前行yy 复制当前行b光标跳转到上一个单词w光标跳转到下一个单词:/要搜索的词 + 回车 搜索i insert模式 ，任意模式模式下按esc进入到命令模式o 移动到光标下一行并新建一行O 移动到光标上一行并新建一行$ 移动光标到行尾 ^ 移动光标到行首 缩进单行代码是两个大于号’&gt;&gt;’回缩就是两个小于号’&lt;&lt;’如果想要缩进很多行代码的话就按照下面做 1 //在这里按下’v’进入选择模式111111//光标移动到这里，再按一次大于号’&gt;’缩进一次，按’6&gt;’缩进六次，按’&lt;’回缩。以下同理 ：%s/vivian/sky/g（等同于：g/vivian/s//sky/g）替换每一行中所有 vivian 为 sky]]></content>
      <categories>
        <category>programming/linux/vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Foundations of Modern Analysis(Friedman 1970)]]></title>
    <url>%2F2016%2F08%2F08%2FFoundations-of-Modern-Analysis-Friedman-1970%2F</url>
    <content type="text"><![CDATA[台交大吴培元实分析泛函分析课程讲义下载download]]></content>
      <categories>
        <category>math/modern analysis</category>
      </categories>
      <tags>
        <tag>modern analysis</tag>
        <tag>real analysis</tag>
        <tag>functional analysis</tag>
        <tag>textbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis and functional analysis 讲义]]></title>
    <url>%2F2016%2F08%2F07%2Freal-analysis-and-functional-analysis%2F</url>
    <content type="text"><![CDATA[台交大吴培元real-analysis-class1.pdfreal-analysis-class10.pdfreal-analysis-class11.pdfreal-analysis-class12.pdfreal-analysis-class13.pdfreal-analysis-class14.pdfreal-analysis-class15.pdfreal-analysis-class16.pdfreal-analysis-class17.pdfreal-analysis-class18.pdfreal-analysis-class19-20.pdfreal-analysis-class2.pdfreal-analysis-class21.pdfreal-analysis-class22.pdfreal-analysis-class23-24.pdfreal-analysis-class25.pdfreal-analysis-class26.pdfreal-analysis-class27.pdfreal-analysis-class28.pdfreal-analysis-class29.pdfreal-analysis-class3.pdfreal-analysis-class30.pdfreal-analysis-class31.pdfreal-analysis-class32.pdfreal-analysis-class33.pdfreal-analysis-class34.pdfreal-analysis-class35.pdfreal-analysis-class36.pdfreal-analysis-class37.pdfreal-analysis-class38.pdfreal-analysis-class39.pdfreal-analysis-class4.pdfreal-analysis-class40.pdfreal-analysis-class41.pdfreal-analysis-class42.pdfreal-analysis-class43.pdfreal-analysis-class44.pdfreal-analysis-class45-46.pdfreal-analysis-class47.pdfreal-analysis-class48.pdfreal-analysis-class49.pdfreal-analysis-class5.pdfreal-analysis-class50.pdfreal-analysis-class52.pdfreal-analysis-class53.pdfreal-analysis-class54-56.pdfreal-analysis-class57.pdfreal-analysis-class58.pdfreal-analysis-class59.pdfreal-analysis-class6.pdfreal-analysis-class60.pdfreal-analysis-class61.pdfreal-analysis-class62.pdfreal-analysis-class63.pdfreal-analysis-class64.pdfreal-analysis-class65.pdfreal-analysis-class66.pdfreal-analysis-class67.pdfreal-analysis-class68.pdfreal-analysis-class69.pdfreal-analysis-class7.pdfreal-analysis-class8.pdfreal-analysis-class9.pdf課程內容.txt]]></content>
      <categories>
        <category>math/real and functional analysis</category>
      </categories>
      <tags>
        <tag>real analysis</tag>
        <tag>functional analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim插件管理器vundle]]></title>
    <url>%2F2016%2F08%2F07%2Fvim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8vundle%2F</url>
    <content type="text"><![CDATA[安装 Vundle 由于 vim 缺乏默认的插件管理器，所有插件的文件都散布在 ~/.vim 下的几个文件夹中，这样导致各种插件的安装、更新、删除都需要自己手动处理，既麻烦费事，又可能出现错误。所以我们需要插件管理器的帮忙，常见的插件管理器有 vundle、pathogen 等等，我们这里使用 vundle。 Vundle 托管在 Github 上，所以使用 git 下载 vundle ，并将其存放于 ~/.vim/bundle/vundle 即可。使用如下命令直接将源代码检出到该目录： 1$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 下载完了 vundle 后，还需要配置 .vimrc 文件。 为了不让 .vimrc 看起来太臃肿，我是新建了一个 ~/.vimrc.bundles 文件来保存所有插件的配置。先在 ~/.vimrc.bundles 文件中包含如下内容： 123filetype off set rtp+=~/.vim/bundle/vundle/call vundle#rc() 然后在 ~/.vimrc 文件中加入内容： 12345678910111213141516171819202122232425262728293031323334353637383940if filereadable(expand("~/.vimrc.bundles")) source ~/.vimrc.bundlesendifset runtimepath^=~/.vim/bundle/ctrlp.vim filetype offset rtp+=~/.vim/bundle/vundle/call vundle#rc()filetype plugin indent on map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;set nu highlight LineNr cterm=bold ctermfg=redhighlight StorageClass cterm=bold ctermfg=darkgreenhighlight Type cterm=bold ctermfg=bluehighlight LineNr cterm=bold ctermbg=blackhighlight phpStructure cterm=bold ctermfg=darkredhighlight phpFunctions cterm=bold ctermfg=256highlight Title ctermfg=blue highlight pythonString cterm=bold ctermfg=grayhighlight pythonFunction cterm=bold highlight pythonInclude cterm=bold ctermfg=lightbluehighlight javaScriptStringS ctermfg=gray highlight String ctermfg=grayhi Search cterm=NONE ctermfg=darkred ctermbg=yellow cterm=reverse set hlsearchset backspace=2set rulerset showmodesyntax on set smartindent set tabstop=4 set shiftwidth=4 set expandtab set softtabstop=4 安装插件以“用户名/repos名”的方式。我们这里将插件的配置信息放在 ~/.vimrc.bundles，如下： 12345678910111213141516171819202122232425262728293031323334353637383940filetype off set rtp+=~/.vim/bundle/vundle/call vundle#rc()&quot; Define bundles via Github repos &quot;Bundle &apos;christoomey/vim-run-interactive&apos;Bundle &apos;Valloric/YouCompleteMe&apos;Bundle &apos;croaky/vim-colors-github&apos;Bundle &apos;danro/rename.vim&apos;Bundle &apos;majutsushi/tagbar&apos;Bundle &apos;kchmck/vim-coffee-script&apos;Bundle &apos;kien/ctrlp.vim&apos;Bundle &apos;pbrisbin/vim-mkdir&apos;Bundle &apos;scrooloose/syntastic&apos;Bundle &apos;slim-template/vim-slim&apos;Bundle &apos;thoughtbot/vim-rspec&apos;Bundle &apos;tpope/vim-bundler&apos;Bundle &apos;tpope/vim-endwise&apos;Bundle &apos;tpope/vim-fugitive&apos;Bundle &apos;tpope/vim-rails&apos;Bundle &apos;tpope/vim-surround&apos;Bundle &apos;vim-ruby/vim-ruby&apos;Bundle &apos;vim-scripts/ctags.vim&apos;Bundle &apos;vim-scripts/matchit.zip&apos;Bundle &apos;vim-scripts/tComment&apos;Bundle &apos;mattn/emmet-vim&apos;Bundle &apos;scrooloose/nerdtree&apos;Bundle &apos;Xuyuanp/nerdtree-git-plugin&apos;Bundle &apos;Lokaltog/vim-powerline&apos;Bundle &apos;godlygeek/tabular&apos;Bundle &apos;msanders/snipmate.vim&apos;Bundle &apos;jelera/vim-javascript-syntax&apos;Bundle &apos;altercation/vim-colors-solarized&apos;Bundle &apos;othree/html5.vim&apos;Bundle &apos;xsbeats/vim-blade&apos;Bundle &apos;Raimondi/delimitMate&apos;Bundle &apos;groenewege/vim-less&apos;&quot; Bundle &apos;evanmiller/nginx-vim-syntax&apos;Bundle &apos;Lokaltog/vim-easymotion&apos;Bundle &apos;tomasr/molokai&apos;Bundle &apos;klen/python-mode&apos; 接着，打开 vim，输入 :BundleInstall 或者直接在终端输入 vim +BundleInstall +qall 安装插件。 YouCompleteMe安装YouCompleteMe的步骤 用vundle中的安装太慢,所以自己手动安装检查是否安装clang、g++、cmake等安装插件管理工具 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在.vimrc中插件管理处加入: 'Valloric/YouCompleteMe'```12安装ycm cd .vim/bundlegit clone https://github.com/Valloric/YouCompleteMe.gitcd YouCompleteMegit submodule update –init –recursive./install.py –clang-completer 12这里安装子模块会出现 fatal: unable to access ‘https://go.googlesource.com/tools/&#39;: Failed to connect to go.googlesource.com port 443: 连接超时fatal: 无法克隆 ‘https://go.googlesource.com/tools&#39; 到子模组路径 ‘/home/zyj/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/x/tools’ 123原因 go.googlesource.com 域名国内无法直接访问，这时候根据 后面的路径 /home/zyj/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/x/tools 来知道该模块是要放这个路径下的到 github 上找到该模块下载到该路径 cd ~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/go/src/golang.org/xgit clone https://github.com/golang/tools.git 12回到 YouComplateMe 目录继续安装其他子模块 cd ~/.vim/bundle/YouCompleteMe 继续子模块的安装git submodule update –init –recursive 122. 去一个你喜欢的目录，例如用户主目录 cd ~ 创建一个目录用来存放接下来要编译的代码的目录mkdir ~/.ycm_build 进入目录cd ~/.ycm_build 编译输出到当前目录(.ycm_build)1cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp 2.1 如果需要实用 C 语言家族的相关功能(我这里系统自带 llvm 3.8、clang 3.8、libclang 没有、libboost-all-dev 没有)，不需要则直接跳过 2.1 1sudo apt install llvm-3.9 clang-3.9 libclang-3.9-dev libboost-all-dev 2.2 编译 YouComplateMe 1# 跳过了 2.1 执行&lt;br&gt;cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp&lt;br&gt;&lt;b 在.vimrc中添加下列 1let g:ycm_global_ycm_extra_conf = &apos;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;]]></content>
      <categories>
        <category>programming/linux</category>
      </categories>
      <tags>
        <tag>linux vim vundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[real analysis 01 overrview]]></title>
    <url>%2F2016%2F08%2F06%2Freal-analysis-01-overrview%2F</url>
    <content type="text"><![CDATA[网址:http://v.youku.com/v_show/id_XMjM0Mjg3NDA4.html?f=5422309老师:台交大吴培元吴老师说：这个课听一遍就可以了，知道后续的理论是有基础的，后来的分析遇到了就翻阅相关内容。数学系所说的实变函数学十遍，听听就好。 分析的不同学习阶段，real analysie 位于第二阶段1 数学分析(微积分)2 实分析(实变函数、实变函数论)3 泛函分析 content:1/3 measure theory1/3 lebsgue integral1/3 probility theory Testbook Real Analysis and Functional analysis history measure Riemann integral Lebesgue integral Advantages of Lebesgue over Riemann1) more applicability2) unified theory3)4) fundamental them of Calculus probility theory]]></content>
      <categories>
        <category>math/real-analysis</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>real-analysis</tag>
      </tags>
  </entry>
</search>
